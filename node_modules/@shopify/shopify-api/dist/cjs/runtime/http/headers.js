'use strict';

function canonicalizeHeaderName(hdr) {
    return hdr.replace(/(^|-)(\w+)/g, (_fullMatch, start, letters) => start +
        letters.slice(0, 1).toUpperCase() +
        letters.slice(1).toLowerCase());
}
function getHeaders(headers, needle_) {
    const result = [];
    if (!headers)
        return result;
    const needle = canonicalizeHeaderName(needle_);
    for (const [key, values] of Object.entries(headers)) {
        if (canonicalizeHeaderName(key) !== needle)
            continue;
        if (Array.isArray(values)) {
            result.push(...values);
        }
        else {
            result.push(values);
        }
    }
    return result;
}
function getHeader(headers, needle) {
    if (!headers)
        return undefined;
    return getHeaders(headers, needle)?.[0];
}
function setHeader(headers, key, value) {
    canonicalizeHeaders(headers);
    headers[canonicalizeHeaderName(key)] = [value];
}
function addHeader(headers, key, value) {
    canonicalizeHeaders(headers);
    const canonKey = canonicalizeHeaderName(key);
    let list = headers[canonKey];
    if (!list) {
        list = [];
    }
    else if (!Array.isArray(list)) {
        list = [list];
    }
    headers[canonKey] = list;
    list.push(value);
}
function canonicalizeValue(value) {
    if (typeof value === 'number')
        return value.toString();
    return value;
}
function canonicalizeHeaders(hdr) {
    for (const [key, values] of Object.entries(hdr)) {
        const canonKey = canonicalizeHeaderName(key);
        if (!hdr[canonKey])
            hdr[canonKey] = [];
        if (!Array.isArray(hdr[canonKey]))
            hdr[canonKey] = [canonicalizeValue(hdr[canonKey])];
        if (key === canonKey)
            continue;
        delete hdr[key];
        hdr[canonKey].push(...[values].flat().map((value) => canonicalizeValue(value)));
    }
    return hdr;
}
function removeHeader(headers, needle) {
    canonicalizeHeaders(headers);
    const canonKey = canonicalizeHeaderName(needle);
    delete headers[canonKey];
}
/*
  Turns a Headers object into a array of tuples, as expected by web standards to
    handle headers that can be specified multiple times.
  [
    ["Set-Cookie", "a=b"],
    ["Set-Cookie", "x=y"],
    // ...
  ]
*/
function flatHeaders(headers) {
    return Object.entries(headers).flatMap(([header, values]) => Array.isArray(values)
        ? values.map((value) => [header, value])
        : [[header, values]]);
}

exports.addHeader = addHeader;
exports.canonicalizeHeaderName = canonicalizeHeaderName;
exports.canonicalizeHeaders = canonicalizeHeaders;
exports.flatHeaders = flatHeaders;
exports.getHeader = getHeader;
exports.getHeaders = getHeaders;
exports.removeHeader = removeHeader;
exports.setHeader = setHeader;
//# sourceMappingURL=headers.js.map
